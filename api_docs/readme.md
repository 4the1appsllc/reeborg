[comment]: # (This readme file is intended for the Javascript documentation generated by jsdoc)

[comment]: # (This directory contains two subdirectories:)

[comment]: # (- `RUR.advanced_world_creation: this is automatically generated from comments in Javascript files processed by jsdoc.)
[comment]: # (- `RUR.hand_written: When generating documentation from source files,)
[comment]: # ( jsdoc allows the inclusion of pre-written "tutorials"; this is)
[comment]: # ( where they are initially located prior to being incorporated in)
[comment]: # ( the full documentation found in advanced_world_creation/.)

[comment]: # (Note that the configuration file for jsdoc is found from the base directory of this project as follows: dev_tools/jsdoc_conf.jsdoc.)

### About this documentation

_This documentation is written for people who wish to create new programming tasks, **going beyond what can be done using the Menu-driven World Editor included in Reeborg's World.** For example, you might want to use different images, including animation, or to add more capabilities to Reeborg's World._  People that simply wish to learn how to use Reeborg's World, or would like to follow a programming tutorial, should use [this link](http://reeborg.ca/docs/en) instead. [Please, note that the link points to a document available in English, French and Korean, with the language chosen using a selector on the right hand side.] _Unlike the other documentation, this one is available only in English.  If needed, you might want to use [http://translate.google.com](http://translate.google.com) to get a version in your own language._

_Other than the documents listed under the **Tutorials** menu above, and the information written on this page, this documentation is generated utomatically using Jsdoc from **comments** included in javascript source files (and not from the actual code, unlike what is usually done for Python by Sphinx.) Since comments are **not** executed, it can happen that they do not reflect what the code is actually doing. If you find that the information provided here is incorrect, or if you have any question or suggestion, please do not hesitate to get in touch with me (Andre.Roberge@gmail.com)._

# Motivation

In my experience in teaching Mathematics and Physics, I have noticed that different examples or problems that I see as testing a single common concept are often seen by students as completely independent one of another, leading them initially to try to memorize a different solution to each, rather than understanding the underlying concept. Often, it will not be until the students have done many superficially different problems by themselves that they will finally understand the underlying concept.  As is the case in Physics and Mathematics, I believe that the same is likely true when teaching programming, and that students can benefit from seeing the same concept illustrated in seemingly very different looking programming assignments.

## Young beginners

While I have no direct experience of teaching young students, the positive feedback I have heard is that Reeborg's World is quite suitable for them to learn the basics of programming.  However, I gather that some students may get bored as each programming task resembles the others.  Looking at other sites aiming to teach young children, I noticed that they most often incorporate colourful images and very nice graphics, much nicer than what is included by default with Reeborg's World. 

The methods described in this documentation are intended to address this issue and offer some potential solutions, to make the learning environment even more appealing to young learners.

## Not so young beginners

Let's face it: older teenagers and young adults may not like to be treated as young children, but they too enjoy environments with better graphics than bland looking ones. Furthermore, they can appreciate an environment such as Reeborg's World that uses a real programming language (Python, or Javascript) and can present them with challenging (but doable) programming tasks with nice visual feedback.

## More advanced students 

Often, programming environments such as Reeborg's World are used to teach beginners, but then abandoned as more advanced concepts are taught, often in a more abstract way. To me, that is a mistake. Once the students have become familiar with a programming environment, especially one that can give visual feedback, it only make sense to revisit this environment to illustrate programming concepts. Beyond simple control flow (`if/else, while, for,` etc.), Reeborg's World can be used to assign problems exploring Object Oriented Programming, including inheritance and composition, data structures (lists/arrays and dict/hash tables in particular), and can even be used to look at various search algorithms (depth-first _vs_ breadth first, A*, etc.).


# Advanced world creation

While the menu driven *World editing dialog* makes it possible to create your own world, it is limited to create worlds with pre-defined objects.  Furthermore, it
creates static worlds which are then interacted with through a user's program.
A world creator may wish to introduce additional interactivity by changing
the state of the world when a user's program has achieved a partial goal,
like reaching a pre-defined position.  The functions documented here are
intended to give world creators all the flexibility they need to create
their own worlds.

This documentation is primarily intended to create worlds using Javascript methods **instead of, or in addition to** using the menu-driven World editor, which provides fewer options. (The vast majority of these methods are also usable _as is_ in a Python program.)



## Menu-driven World editor _vs_ Programming methods.

In what follows, I will create a world first using the Menu-driven editor, and then using Javascript methods. An animated gif is shown, illustrating the result at each step. (Note that, as Reeborg's World changes, the interface may look a bit different from what you will see on these images.)

If you want, you can right-click on each image to open it in another tab and view it at a larger scale.


### Using the World editor

Let's create a simple world, with Reeborg already in it, and have three walls surround the home location which Reeborg would have to reach to complete the programming task.

1. Start with a simple world with Reeborg already in it.
2. Navigate the menus to open the Menu-driven World editor; note how the appearance of the world changes, indicating we are in "edit mode".
3. Use the menu to add 3 walls an set a location as the final desired position.
4. Save the world in the browser (local storage).  Later, if you wish, you can save it in a .json file.
5. Dismiss the World editor; note how the world's appearance changes back to its normal state.
6. By saving it in the browser, the world has been added to the html selector; worlds stored in the browser appear with a pale yellow background in the html selector.

![editor][editor_link]

[editor_link]: ../../src/images/create_world.gif

### Using the Javascript methods

Let's reproduce the same world using the Javascript methods instead. In the animated gif, I have run these as instructions in a Python program instead of a Javascript one.

1. Start with a simple world with Reeborg already in it.
2. Enter the program required to create the 3 walls and the final position for Reeborg to reach.
3. Run the program. Note how the various "things" are added ... and how we get an error dialog at the end indicating that Reeborg has **not** accomplished the required task.
4. Navigate the menus to open the World editor.
   - Note how the world we saved previously is mentioned, with a button allowing us to delete it from the browser's memory (local storage) if we wish.
5. Save the world in the browser, and dismiss the World edit window.  
6. Like before, by saving it in the browser, the world has now been added to the html selector.

![methods][methods_link]

[methods_link]: ../../src/images/create_world2.gif

For future reference, the code used in the above example was:

```
RUR.add_wall("east", 4, 2)
RUR.add_wall("north", 4, 2)
RUR.add_wall("west", 4, 2)
RUR.add_final_position("house", 4, 2)
```

## About the RUR namespace

Since the goal of Reeborg's World is to allow the user (student) to
run their own programs, name clashes have to be avoided between functions
created for Reeborg's World and those created by the student.
The imperfect solution I have chosen is to try, as much as possible, to use
a single global object or namespace,
`RUR`, which can stand for **Reeborg the UsedRobot**, and is also valid
in French as _le **Robot Usag√© Reeborg**_. It also refers to the first time the
name **robot** was used [see wikipedia:RUR](https://en.wikipedia.org/wiki/R.U.R.).

Please note that there are many more functions belonging to the `RUR` namespace
than what is documented here.  As a general rule, you should not create additional functions belonging to this namespace; however, some suggested exceptions are mentioned later in this documentation.


# Next steps

I suggest that you use the **Tutorials** menu on top, and go through the topics in order, starting with the Naming convention. Later, use the **Namespaces** menu for quick reference.

