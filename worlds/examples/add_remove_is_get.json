{
  "robots": [
    {
      "x": 1,
      "y": 1,
      "_prev_x": 1,
      "_prev_y": 1,
      "_prev_orientation": 0,
      "objects": {},
      "_orientation": 0,
      "_is_leaky": true,
      "_trace_history": [],
      "_trace_style": "default",
      "_trace_color": "seagreen",
      "__id": 6,
      "possible_initial_positions": [
        [
          1,
          1
        ]
      ]
    }
  ],
  "walls": {},
  "description": "This world demonstrates the use of various functions to\nadd or remove various artefacts, \nto see if a certain type of artefact is present\nat a given location, and to find out which artefacts\nare present at a given location. The code is in the \"Pre\"\neditor.\n\nThis world is also intended to be used in some automated tests.\n\nThe content of the \"Pre\" editor is the following:\n\nINSERT_PRE",
  "small_tiles": false,
  "rows": 10,
  "cols": 10,
  "pre": "# Background tiles are the simplest: there\n# can only be one at a given location\n\nassert not RUR.is_background_tile(\"water\", 2, 1)\nRUR.add_background_tile(\"water\", 2, 1)\nassert RUR.is_background_tile(\"water\", 2, 1)\nassert \"water\" == RUR.get_background_tile(2, 1)\n#--------\n# Note: get_background_tile is singular as there can be only\n# one at a given location\n#---------\n\nRUR.add_background_tile(\"grass\", 2, 1)\n# grass replaced water\nassert RUR.is_background_tile(\"grass\", 2, 1)\nassert not RUR.is_background_tile(\"water\", 2, 1)\n\n#-------------------------------------------\n# Decorative objects; there can be more than\n# one at a given location.\n\nassert not RUR.is_decorative_object(\"tulip\", 3, 1)\nRUR.add_decorative_object(\"tulip\", 3, 1)\nassert RUR.is_decorative_object(\"tulip\", 3, 1)\n\nRUR.add_decorative_object(\"carrot\", 3, 1)\n# Both decorative objects are now present\nassert RUR.is_decorative_object(\"tulip\", 3, 1)\nassert RUR.is_decorative_object(\"carrot\", 3, 1)\n\n# note the plural form of get_decorative_objects\nassert [\"tulip\", \"carrot\"] == RUR.get_decorative_objects(3, 1)\nRUR.remove_decorative_object(\"carrot\", 3, 1)\nassert [\"tulip\"] == RUR.get_decorative_objects(3, 1)\n\n# Decorative objects are drawn on top of background tiles\nRUR.add_decorative_object(\"daisy\", 2, 1)\n\n#-----------------------------------------------\n# Obstacles follow the same rules as decorative objects\n\nassert not RUR.is_obstacle(\"fence_left\", 4, 1)\nRUR.add_obstacle(\"fence_left\", 4, 1)\nassert RUR.is_obstacle(\"fence_left\", 4, 1)\n\nRUR.add_obstacle(\"fire\", 4, 1) # animated\n# Both obstacles are now present\nassert RUR.is_obstacle(\"fence_left\", 4, 1)\nassert RUR.is_obstacle(\"fire\", 4, 1)\nassert [\"fence_left\", \"fire\"] == RUR.get_obstacles(4, 1)\n\nRUR.remove_obstacle(\"fence_left\", 4, 1)\nassert [\"fire\"] == RUR.get_obstacles(4, 1)\n\n# Obstacles are drawn on top of decorative objects\nRUR.add_decorative_object(\"fence_vertical\", 2, 1)\n\n#-----------------------------------------------\n# Bridges follow the same pattern as background tiles:\n# there can only be one at a given location\n\nassert not RUR.is_bridge(\"apple\", 5, 1)\n# we can use anything as a bridge\nRUR.add_bridge(\"apple\", 5, 1)\nassert RUR.is_bridge(\"apple\", 5, 1)\nassert \"apple\" == RUR.get_bridge(5, 1) # bridge: singular\n\nRUR.add_bridge(\"bridge\", 5, 1)\n# bridge replaced apple\nassert RUR.is_bridge(\"bridge\", 5, 1)\nassert not RUR.is_bridge(\"apple\", 5, 1)\n\n# Bridges are drawn on top of background tiles\n# but below everything else\nRUR.add_bridge(\"bridge\", 2, 1)\n\n#-----------------------------------------------\n# Objects have the most options; here we do not\n# include \"goals\" but show most other options.\n\nassert RUR.get_objects(6, 1) is None\nassert not RUR.is_object(\"token\", 6, 1)\n\nRUR.add_object(\"token\", 6, 1)\nassert RUR.is_object(\"token\", 6, 1)\nassert not RUR.is_object(\"daisy\", 6, 1)\n\nRUR.add_object(\"daisy\", 6, 1)\nassert RUR.is_object(\"token\", 6, 1)\nassert RUR.is_object(\"daisy\", 6, 1)\n\nRUR.add_object(\"token\", 6, 1)\nassert dict(RUR.get_objects(6, 1)) == {\"daisy\": 1, \n                                       \"token\": 2}\n\nRUR.add_object(\"token\", 6, 1, {\"number\":10})\nassert dict(RUR.get_objects(6, 1)) == {\"daisy\": 1, \n                                       \"token\": 12}\n\nRUR.remove_object(\"token\", 6, 1)\nassert dict(RUR.get_objects(6, 1)) == {\"daisy\": 1, \n                                       \"token\": 11}\n\nRUR.remove_object(\"token\", 6, 1, {\"number\": 5})\nassert dict(RUR.get_objects(6, 1)) == {\"daisy\": 1, \n                                       \"token\": 6}\n\nRUR.remove_object(\"token\", 6, 1, {\"all\": True})\nassert dict(RUR.get_objects(6, 1)) == {\"daisy\": 1}\n\n# objects are drawn on top of obstacles and everything\n# else mentioned above\nRUR.add_object(\"token\", 2, 1)\n\n#-----------------------------------------------\n# Pushable: there can be only one at a given location -\n# but, beware the possibility of raising an exception.\n\n# we can use anything as a pushable\nassert not RUR.is_pushable(\"orange\", 7, 1)\nRUR.add_pushable(\"orange\", 7, 1)\nassert RUR.is_pushable(\"orange\", 7, 1)\nassert \"orange\" == RUR.get_pushable(7, 1) # pushable: singular\n\n# If we attempt to add a second pushable at a given\n# location, an exception is raised\n\nexception_raised = False\ntry:\n    RUR.add_pushable(\"box\", 7, 1)\nexcept ReeborgError:\n    exception_raised = True\n\nassert exception_raised\n\nRUR.remove_pushable(\"orange\", 7, 1)\nRUR.add_pushable(\"box\", 7, 1)\nassert \"box\" == RUR.get_pushable(7, 1)\n\n# Pushables are drawn on top of everything else;\nRUR.add_obstacle(\"water\", 10, 1)\nRUR.add_pushable(\"token\", 10, 1)\n\n#-----------------------------------------------\n# Walls are similar to other types ... but with a twist\n\nassert not RUR.is_wall(\"east\", 3, 3)\nRUR.add_wall(\"east\", 3, 3)\nassert RUR.is_wall(\"east\", 3, 3)\n\n# The wall we added is to the \"west\" of (4, 3)\nassert RUR.is_wall(\"west\", 4, 3)\n\n# We can add a different wall at the same location\nRUR.add_wall(\"north\", 3, 3)\n# Unlike other artefacts, the order in which\n# they are listed in the array/list returned by\n# RUR.get_walls is not necessarily the order in which\n# they were added since the same wall can be referred\n# to in different ways based on neighbouring positions.\nassert \"east\" in RUR.get_walls(3, 3)\nassert \"north\" in RUR.get_walls(3, 3)\n\n# If we attempt to add a second identical wall at a given\n# location, an exception is raised\n\nexception_raised = False\ntry:\n    RUR.add_wall(\"east\", 3, 3)\nexcept ReeborgError:\n    exception_raised = True\n\nassert exception_raised\n\n# Finally, we can remove walls; here we will remove\n# the \"north\" wall at (3, 3) from the grid position above\nRUR.remove_wall(\"south\", 3, 4)\nassert [\"east\"] == RUR.get_walls(3, 3)\n\n",
  "onload": "RUR.onload_set_programming_language(\"python\")\n"
}